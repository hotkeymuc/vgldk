//#ifndef __BDOS_C
//#define __BDOS_C

/*
	BDOS - Basic Disk Operating System
	==================================
	
	The BDOS talks to the BIOS and takes care of file access.
	
	Reference: https://www.seasip.info/Cpm/bdos.html
	
	TODO:
		* Use "#pragma callee-saves" / command line option "--callee-saves bdos, ..."
		
	
	2023-08-15 Bernhard "HotKey" Slawik
*/

#include "fcb.h"	// For files
#include "bdos.h"
#include "bios.h"	// For basic I/O
#include "bint.h"	// For restoring interrupt vector(s)

// This file is auto-generated by cpm_make.py.
#include "lowstorage.h"	// For restoring it at boot


// First bytes of the _CODE area should be the BDOS entry function.
// The jump at CRT0 0x0005 should point here.
// Its address marks the end of the transient memory area (e.g. ZORK checks 0x0005 for that address to determine maximum RAM usage).
void bdos() __naked {
	__asm
		
		; Jump into table...
		ld hl, #_bdos_funcs	; BDOS function jump table
		
		; Function number is stored in C.
	
		; Add it to the address (as BC, so just zero out B and we are fine)
		ld b, #0
		; Table consists of "JP xxxx" (3 bytes) entries. So add BC 3 times.
		add hl, bc
		add hl, bc
		add hl, bc
		
		jp (hl)	; Jump to BDOS function jump
		
	__endasm;
}



// Std. I/O Helpers
// Make puts / gets etc. talk directly to BIOS
//void bdos_putchar(char c) {	bios_conout(c); }
//byte bdos_getchar() { return bios_conin(); }
#define bdos_putchar bios_conout
#define bdos_getchar bios_conin

void bdos_puts(const char *str) {
//void bdos_puts(const char *str, char delimiter) {
	// Output zero terminated string
	while(*str) bios_conout(*str++);
	
	// Output variable terminated string
	//while(*str != delimiter) bios_conout(*str++);
	
	// New line after puts()
	//bios_conout('\r');
	bios_conout('\n');
}
//void bdos_gets(char *pc) {
//void bdos_gets(char *pc, char delimiter) {
void bdos_gets(char *pc, byte max_size) {
	char *pcs;
	char c;
	pcs = pc;
	byte l;
	
	l = 0;
	while(1) {
		c = bios_conin();
		
		// Echo
		bios_conout(c);
		
		if ( (c == 8) || (c == 127) ) {
			// Backspace/DEL
			if (l > 0) {
				pcs--;
				l--;
				// Update display? Clear old character?
			}
			continue;
		}
		
		// ENTER, EOF
		if ((c == '\n') || (c == '\r') || (c == 0x1a) || (c == 0)) {
			// End of string
			
			// Terminate string with zero
			*pcs = 0;
			
			// Terminate string with given delimiter
			//*pcs = delimiter;
			return;
		}
		
		if (l >= max_size) {
			//sound_beep();
			continue;
		}
		
		// Add char to buffer
		*pcs++ = c;
		l++;
	}
	
	//return pcs;
}

void bdos_printf(char *pc) {
	while(*pc) bios_conout(*pc++);
}

// Helper to write "not implemented"
void bdos_not_implemented(char *t) {
	bdos_printf("bdos_");
	bdos_printf(t);
	bdos_puts(" n/i!");
}

// Publish as stdio
//@FIXME: Use stdlib! Only define getchar/putchar!
//#define putchar bdos_putchar
//#define puts bdos_puts
//#define printf bdos_printf

/*
#define HEX_USE_DUMP	// Include dump()
#include <hex.h>
#define bdos_printf_x2 printf_x2
#define bdos_printf_x4 printf_x4
*/
/*
//void bdos_printf_d(char *pc, byte d) {
void bdos_printf_d(byte d) {
	byte i;
	//bdos_printf(pc);
	i = 100;	// Maximum decimal digit (1/10/100/1000/...)
	while(i > 0) {
		bios_conout('0' + ((d / i) % 10));
		i /= 10;
	}
}
*/
byte bdos_hexDigit(byte c) {
	if (c < 10) return ('0'+c);
	return 'A' + (c-10);
}
void bdos_printf_x2(byte b) {
	bios_conout(bdos_hexDigit(b >> 4));
	bios_conout(bdos_hexDigit(b & 0x0f));
}
void bdos_printf_x4(word w) {
	bdos_printf_x2(w >> 8);
	bdos_printf_x2(w & 0x00ff);
}


/*
void bdos_dump(word a, byte len) {
	byte i;
	byte b;
	byte *o;
	
	// Simple dump
	bdos_printf_x4(a);
	bdos_putchar('|');
	
	o = (byte *)a;
	for(i = 0; i < len; i++) {
		b = *o;
		if (b < 0x20)	bdos_putchar('.');
		else			bdos_putchar(b);
		o++;
	}
	
	bdos_putchar('|');
	//bdos_printf(" | ");
	//if (len != 16) bdos_printf("\n");
	
	o = (byte *)a;
	for(i = 0; i < len; i++) {
		b = *o;
		bdos_printf_x2(b);
		o++;
	}
	bdos_putchar('\n');
}
*/


// String Helpers
#include <stringmin.h>
#define bdos_strlen strlen
#define bdos_memcpy memcpy
#define bdos_memset memset
/*
byte bdos_strlen(const char *c) {
	byte l;
	l = 0;
	while (*c++ != 0)  {
		l++;
	}
	return l;
}
void bdos_memset(byte *addr, byte b, word count) {
	while(count > 0) {
		*addr++ = b;
		count--;
	}
}
*/


// Host communication (FCB)
#ifdef BDOS_USE_HOST
	#include "bdos_host.h"
#endif


#ifdef BDOS_TRAP
	#include "bdos_trap.h"
#endif

// CCP start-up
void bdos_start_ccp(); // Forward

// Well-known BDOS functions
void bdos_init() __naked {	// BDOS_FUNC_P_TERMCPM:	// 0: System Reset
	
	// Called by bios_wboot()
	
	// Show BDOS banner (BIOS shows CP/M banner)
	#ifdef BDOS_SHOW_BANNER
		bdos_printf("BDOS: ");
	#endif
	
	#ifdef BDOS_WAIT_FOR_RAM
		// Wait until RAM is accessible (writable)
		
		byte *check_addr;
		byte check_old;
		byte check_new;
		byte check_actual;
		word checks;
		
		// Address to perform write check
		//check_addr = (byte *)0x0100;	// Check transient start
		//check_addr = (byte *)0x7fff;	// Check 32KB top
		check_addr = (byte *)0x3fff;	// Check 16KB top
		
		bdos_printf("RAM check...");
		//@TODO: Maybe throttle this (in case there is FLASH installed)
		checks = 0;
		do {
			// Get old value
			check_old = *check_addr;
			
			// Generate new value
			check_new = check_old ^ 0xff;
			
			// Write the new value
			*check_addr = check_new;
			
			// Check if it changed
			check_actual = *check_addr;
			
			if (checks < 0x7fff) checks ++;
		} while (check_actual != check_new);
		
		bdos_puts("OK");
		
		// Debounce if it seems like a "hot swap" has occured (which took some time)
		// If check passed instantly, we do not need to debounce.
		if (checks > 1)
		for (word i = 0; i < 0xffff; i++) {
			__asm
				nop
			__endasm;
		}
		
	#endif
	
	#ifdef BDOS_RESTORE_LOWSTORAGE
		// Restore lowstorage for next cold-boot (lowest 0x5c bytes, the rest at 0x5c... is def_fcb, bios_dma and transient)
		//bdos_memcpy((byte *)0x0000, &lowstorage_data[0], 0x5c);
		bdos_memcpy((byte *)lowstorage_origin, &lowstorage_data[0], lowstorage_size);
		
		//@TODO: Verify?
	#endif
	
	/*
	// Restore/set the cold boot vector (if not known at compile time)
	// It is assumed to be the last 3 bytes in lowstorage cold boot code...
	*((byte *)(0x0059)) = 0xc3;	// JP ...
	*((word *)(0x005a)) = (word)&bios_boot;	// to bios_boot
	*/
	
	#ifdef BDOS_RESTORE_BDOS_VECTOR
		// Restore BDOS vector at 0x0005 (if corrupted / fresh boot)
		*((byte *)(0x0005)) = 0xc3;	// JP ...
		*((word *)(0x0006)) = (word)&bdos;	// to BDOS
	#endif
	
	#ifdef BDOS_RESTORE_BINT_VECTORS
		// Restore BINT interrupt vector(s)
		word a;
		for (a = 0x0008; a <= 0x0038; a += 0x0008) {
			*((byte *)(a)) = 0xc3;	// JP ...
			*((word *)(a+1)) = (word)&bint;	// to BINT
		}
	#endif
	
	// Configure state
	bios_setdma((byte *)0x0080);	// Is already done at bios_wboot()
	
	bdos_delimiter = '$';
	bdos_user = 1;	//@FIXME: This should be the upper bits of the bios_curdsk at 0x0004
	
	bdos_memset((byte *)bdos_fcb, 0x00, 36);	//sizeof(FCB));	// Clear default fcb
	bdos_fcb_num = 0;	// currently used FCB number in DMA area (0...3)
	
	#ifdef BDOS_PATCHED_ENTRY_ADDRESS
		// At the moment, the BODS entry point "bdos()" might not be at the top of RAM / bottom of code segment.
		// It may actually be in a different memory segment or even in ROM (i.e. not writable at all).
		
		// So: We need to patch the JP instruction at 0x0005 to point to the end of RAM.
		// Example: ZORK1.COM looks at the address at 0x0006 to determine RAM size and where to put its own data.
		// So 0x0006 MUST point to the top of RAM, or at least below the BDOS/BIOS/CCP code segment.
		
		// Clone the original jump instruction from 0x0005 to the end of RAM
		// It consists of three bytes: 0xC3 [lo] [hi]
		memcpy((byte *)BDOS_PATCHED_ENTRY_ADDRESS, (byte *)0x0005, 3);	// Copy original BDOS vector
		
		// Alter the pointer at 0x0006 to point to the cloned jump
		// We use 0x0006, since the byte at 0x0005 is 0xc3 (opcode for "JP") and the actual address is at 0x0006 and 0x0007
		*(word *)0x0006 = BDOS_PATCHED_ENTRY_ADDRESS;
	#endif
	
	
	// Load CCP to transient area and run it
	#ifdef BDOS_AUTOSTART_CCP
		bdos_start_ccp();
	#else
		// Allow NOT starting CCP, e.g. when debugging using serial monitor.
		while(1) {
			//bdos_printf("Load CCP [Y/N]?");
			bdos_printf("Load CCP?");
			char c = bdos_getchar();
			
			if (c == 'N') {
				// Go "back" to cartridge ROM
				bdos_printf("cart...");
				__asm
					jp 0x8000
				__endasm;
			}
			
			if (c == 'Y') {
				bdos_start_ccp();
			}
			
			// Else
			bdos_printf_x2(c);
			bdos_putchar('?');
		}
	#endif
}

void bdos_c_read() __naked {	// BDOS_FUNC_C_READ:	// 1: Console input
	/*
	char c = bios_conin();	// Get a char from bios
	bios_conout(c);	// Echo it (as spec.)
	bdos_return1(c);	// Return it
	*/
	__asm
		call _bios_conin
		; Result should be in L
		
		; Local echo (as per spec.)
		push hl	; Push parameter L (dont care about D). L will be the most recent stack argument, thats all that matters.
		call _bios_conout
		pop hl	; Pop parameter(s)
		
		; Result is still in L, great! So just return.
		ret
	__endasm;
}

void bdos_c_write(char c) __naked {	// BDOS_FUNC_C_WRITE:	// 2: Console output
	(void)c;	// Silence the  compiler about unused argument
	
	//bios_conout(bdos_param_e);
	__asm
		push de	; Push parameter E (dont care about D). E will be the most recent stack argument, thats all that matters.
		call _bios_conout
		pop de	; Pop the parameter(s). We pushed D and E, so we must pop both.
		ret
	__endasm;
}

void bdos_a_read() __naked {	// BDOS_FUNC_A_READ:	// 3: Reader input (blocking)
	//s = bios_reader();	// Get a char from bios
	//// Return ^Z on EOF
	//bdos_return1(s);	// Return it
	__asm
		call _bios_reader
		; Result should be in L
		
		; ; Local echo (as per spec.)
		; push hl	; Push parameter L (dont care about D). L will be the most recent stack argument, thats all that matters.
		; call _bios_conout
		; pop hl	; Pop parameter(s)
		
		; Result is still in L, great! So just return.
		ret
	__endasm;
}

void bdos_a_write(char c) __naked {	//BDOS_FUNC_A_WRITE:	// 4: Punch output
	(void)c;	// Silence the  compiler about unused argument
	
	//bios_punch(bdos_param_e);
	__asm
		push de	; Push parameter E (dont care about D). E will be the most recent stack argument, thats all that matters.
		call _bios_punch
		pop de	; Pop the parameter(s). We pushed D and E, so we must pop both.
		ret
	__endasm;
}

void bdos_l_write(char c) __naked {	// BDOS_FUNC_L_WRITE:	// 5: List output
	(void)c;	// Silence the compiler about unused argument
	
	//bios_list(bdos_param_e);
	__asm
		push de	; Push parameter E (dont care about D). E will be the most recent stack argument, thats all that matters.
		call _bios_list
		pop de	; Pop the parameter(s). We pushed D and E, so we must pop both.
		ret
	__endasm;
}

void bdos_c_rawio(char c, char e) __naked {	//BDOS_FUNC_C_RAWIO:	// 6: Direct console I/O
	// Entered with C=6, E=code. Returned values (in A) vary.
	(void)c;
	(void)e;
	
	__asm
		ld a, e
		cp a, #0xff
		jr z, 0$
		
		ld a, e
		cp a, #0xfe
		jp z, 4$
		
		ld a, e
		cp a, #0xfd
		jr z, 2$
		
		ld a, e
		cp a, #0xfc
		jr z, 3$
		
		; Else: CONOUT
		push de
		call _bios_conout
		pop de
		ret
		
	0$:	; 0xff = Return a character without echoing if one is waiting; zero if none is available. In MP/M 1, this works like E=0FDh below and waits for a character.
		
		call _bios_const	; Get key state
		ld a, l	; Get return from L
		
		cp a, #0xff	; 0xff = key is pressed
		jr nz, 1$
		
		call _bios_conin	; Jump to CONIN
		ld a, l
		ret
		
	1$:
		; No new key. Return 0
		ld l, #0
		ret
	
	2$:	; 0xfd = [CP/M3, DOS+] Wait until a character is ready, return it without echoing.
		jp _bios_conin	; // Do NOT echo it!
		
	3$:	; 0xfc = [DOS+] One-character lookahead - return the next character waiting but leave it in the buffer.
		ld l, #0
		ret
	
	4$:	; 0xfe = [CP/M3, NovaDOS, Z80DOS, DOS+] Return console input status. Zero if no character is waiting, nonzero otherwise.
		call _bios_const	; Get key state
		ld a, l	; Get return from L
		
		cp a, #0xff	; 0xff = key is pressed
		jr nz, 1$
		
		; key is pressed
		ld a, l
		ret
	__endasm;
	
	
	/*
	(void)c;(void)e;	// Silence the compiler about unused argument
	switch(bdos_param_e) {
		case 0xff:
			// Return a character without echoing if one is waiting; zero if none is available. In MP/M 1, this works like E=0FDh below and waits for a character.
			//bdos_return1(inkey());	// Non-blocking! Do NOT echo!
			
			c = bios_const();
			if (c == 0xff) {	// Key is pressed
				c = bios_conin();	// Get that key
				//if (c == getchar_last) bdos_return1(0);	// No new key
			} else {
				//getchar_last = 0;
				bdos_return1(0);	// No new key
			}
			
			// New key
			//getchar_last = c;
			bdos_return1(c);
			break;
			
		case 0xfe:
			// [CP/M3, NovaDOS, Z80DOS, DOS+] Return console input status. Zero if no character is waiting, nonzero otherwise.
			//bdos_return1(checkkey());
			bdos_return1(bios_const());
			break;
		case 0xfd:
			// [CP/M3, DOS+] Wait until a character is ready, return it without echoing.
			//bdos_return1(getchar());	// Do NOT echo!
			bdos_return1(bios_conin());	// Do NOT echo!
		case 0xfc:
			// [DOS+] One-character lookahead - return the next character waiting but leave it in the buffer.
			bdos_return1(0);
		default:
			bios_conout(bdos_param_e);
	}
	*/
}

void bdos_get_iobyte() __naked {	// BDOS_FUNC_GET_IOBYTE:	// 7: Get I/O Byte
	//bdos_return1(bios_iobyte);
	__asm
		push af
		ld a, (_bios_iobyte)
		ld l, a
		pop af
		ret
	__endasm;
}

void bdos_set_iobyte(char c) __naked {	// BDOS_FUNC_SET_IOBYTE:	// 8: Set I/O Byte
	(void)c;	// Silence the compiler about unused argument
	//bios_iobyte = bdos_param_e;
	__asm
		push af
		ld a, e
		ld (_bios_iobyte), a
		pop af
		ret
	__endasm;
}

void bdos_c_writestr(char *de) __naked {	// BDOS_FUNC_C_WRITESTR:	// 9: Print string (until delimiter "$")
	(void)de;	// Silence the compiler about unused argument
	
	// pc = (char *)bdos_param_de;
	// while(*pc != bdos_delimiter) {
	// 	bios_conout(*pc++);
	// }
	__asm
		push af
		push bc
		
		ld a, (_bdos_delimiter)
		ld b, a
		
	0$:
		ld a, (de)	; get byte
		cp a, b	; check for delimiter
		jr z, 1$	; delimiter? break!
		
		; Invoke bios_conout with A on stack
		push af	; Push AF...
		inc sp	; ...but neglect the F
		call _bios_conout
		inc sp	; Clean up rest of AF off the stack
		
		; increment DE and loop
		inc de
		jp 0$
		
	1$:
		pop bc
		pop af
	__endasm;
	
}


//@FIXME: Do it differently
volatile byte bdos_readstr_param_d;
volatile byte bdos_readstr_param_e;
void bdos_c_readstr(char *de) __naked {	// BDOS_FUNC_C_READSTR:	// 10: Read console buffer
	word bdos_param_de;
	char *pc;
	char s;
	
	// DE points to buffer (first byte is max size). Special case: DE=0 = use DMA area
	(void)de;	// Silence the compiler about unused argument
	//bdos_printf("DE="); bdos_printf_x4(bdos_param_de); bdos_getchar();
	__asm
		; Store register "D"
		ld a, d
		ld (_bdos_readstr_param_d), a
		
		; Store register "E"
		ld a, e
		ld (_bdos_readstr_param_e), a
	__endasm;
	
	bdos_param_de = (word)bdos_readstr_param_d * 256 + (word)bdos_readstr_param_e;
	if (bdos_param_de == 0) bdos_param_de = (word)bios_dma;	// 0x0080
	
	pc = (char *)bdos_param_de;
	s = *pc;	// First byte contains maximum buffer size
	
	// Actually read str (as zero-terminated c string)
	bdos_gets(pc+2, s);	// +0=max_size, +1=len, +2=data (without CR/LF)
	
	// Determine length
	s = bdos_strlen(pc+2);
	
	// Write string length to second byte
	*(pc+1) = s;
	
	// Add delimiter character
	//pc = (char *)(bdos_param_de + s);
	// *pc = bdos_delimiter;
	
	__asm
		ret
	__endasm;
	
}

void bdos_c_stat() __naked {	// BDOS_FUNC_C_STAT:	// 11: Get console status
	// Returns A=0 if no characters are waiting, nonzero if a character is waiting.
	//bdos_return1(bios_const());
	__asm
		call _bios_const
		; Result should be in L now
		ld a, l
		ret
	__endasm;
}
void bdos_s_bdosver() __naked {	// BDOS_FUNC_S_BDOSVER:	// 12: Return version number
	// Returns B=H=system type, A=L=version number.
	// type = 0=8080, 1=8086, 2=68000/Z8000; bit 0 = MP/M, bit 1 = CP/Net, bit 2 = 16-Bit multi-user
	// Version: Hex representation of major and minor number, e.g. 0x22 = v2.2
	
	//bdos_return2(0, 0x22);
	__asm
		ld a, #0
		ld b, a
		ld h, a
		
		ld a, #0x22
		ld l, a
		ret
	__endasm;
}

void bdos_drv_allreset() __naked {	// BDOS_FUNC_DRV_ALLRESET:	// 13: Reset disk system
	//@TODO: Implement
	// Close disks, reset DMA, forget directory
	return;
}

void bdos_drv_set(byte e) __naked {	// BDOS_FUNC_DRV_SET:	// 14: Select disk
	(void)e;	// Silence the  compiler about unused argument
	// cpm_drive = bdos_param_e;	// 0 = A, 1 = B
	
	//@TODO: If disk not available: return A=0xff, H=1
	
	//bios_seldsk(bdos_param_e);
	//bdos_return1(0);	// 0 = OK, 0xff = error
	/*
	// Log which disk
	__asm
		push de
		call _bdos_printf_x2
		pop de
	__endasm;
	*/
	
	__asm
		push de
		call _bios_seldsk
		pop de
		
		ld a, #0	; 0 = OK, 0xff = error
		ld l, a
	
		ret
	__endasm;
}

byte bdos_f_open_(struct FCB *fcb) {
	
	#ifdef BDOS_USE_HOST
		byte r;
		// Send request to host
		bdos_host_sendfcb(BDOS_FUNC_F_OPEN, fcb);
		
		//@TODO: Receive to different location (fcb_result) inside DMA area and return its 32-byte index (0...3)
		r = bdos_host_receivefcb(fcb);
		
		if (r != 0xff) {
			fcb->s2 |= 0x80;	// Mark open?
			
			/*
			//bdos_file_ofs = 0;
			fcb->ex = 0;	// Current extent
			fcb->s1 = 2;	//@TODO: ?
			fcb->s2 |= 0x80;	// mark "open"?
			fcb->rc = 0x80;	// @TODO: Number of records in extend
			//fcb->d = .... whatever
			fcb->cr = 0;
			fcb->r0 = 0;
			fcb->r1 = 0;
			fcb->r2 = 0;
			// Rest is zero
			*/
			
			//@FIXME: Not sure if this is part of CP/M 2.2!
			// Mirror FCB to DMA area and return its 32-byte DMA-offset
			//bdos_memcpy((byte *)0x0080, (byte *)fcb, 36);
			return 0;	// 0-3 = OK
		}
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_open");
		(void)fcb;
	#endif
	return 0xff;	// Error
}
byte bdos_f_open(struct FCB *fcb) __naked {	// BDOS_FUNC_F_OPEN:	// 15: Open file
	(void)fcb;
	
	// DE = FCB address
	// A = Result (0xff = error, 0-3 = OK)
	// Some versions (including CP/M 3) always return zero; others return 0-3 to indicate that an image of the directory entry is to be found at (80h+20h*A).
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_open_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return B=H=0
		ld a, #0
		ld b, a
		ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}

byte bdos_f_close_(struct FCB *fcb) {
	byte r;
	
	#ifdef BDOS_USE_HOST
		bdos_host_sendfcb(BDOS_FUNC_F_CLOSE, fcb);
		r = 0x00;
		
		// if (r != 0xff) {
			fcb->s2 &= 0x7f;	// remove "open" flag?
		// }
	#else
		//@TODO: Implement bare-metal version
		(void)fcb;	// Quiet the compiler
		bdos_not_implemented("f_close");
		r = 0xff;
	#endif
	
	return r;
}
byte bdos_f_close(struct FCB *fcb) __naked {	// BDOS_FUNC_F_CLOSE:	// 16: Close file
	(void)fcb;
	
	// DE = FCB address
	// A = Result (0xff = error, 0-3 = OK)
	// This function closes a file, and writes any pending data. This function should always be used when a file has been written to.
	// Some versions (including CP/M 3) always return zero; others return 0-3 to indicate that an image of the directory entry is to be found at (80h+20h*A).
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_close_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return B=H=0
		ld a, #0
		ld b, a
		ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}

// Use one implementation for both "sfirst" and "snext", supply the function number in f
byte bdos_f_s_(struct FCB *fcb, byte f) {
	
	//bdos_puts("bdos_f_sfirst_...");
	#ifdef BDOS_USE_HOST
		byte r;
		struct FCB *fcb_result;
	
		// Send given FCB
		//host_sendfcb(BDOS_FUNC_F_SFIRST, fcb);
		//host_sendfcb(BDOS_FUNC_F_SNEXT, fcb);
		bdos_host_sendfcb(f, fcb);	// Note the dynamic function number!
		
		// Chose free FCB in DMA area
		bdos_fcb_num = (bdos_fcb_num + 1) & 0x03;	// 0...3
		fcb_result = (struct FCB *)((word)bios_dma + bdos_fcb_num * 32);
		
		// Receive into this area
		r = bdos_host_receivefcb(fcb_result);
		
		// Result 0xff means error
		if (r == 0xff) return 0xff;
	
		// Return result fcb number (32-byte offset in DMA area, 0-3)
		return bdos_fcb_num;
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_s");
		(void)fcb;	// Quiet the compiler
		(void)f;
		return 0xff;
	#endif
}
/*
byte bdos_f_sfirst_(struct FCB *fcb) {
	byte r;
	struct FCB *fcb_result;
	
	//bdos_puts("bdos_f_sfirst_...");
	#ifdef BDOS_USE_HOST
		// Send given FCB
		host_sendfcb(BDOS_FUNC_F_SFIRST, fcb);
		
		// Chose free FCB in DMA area
		bdos_fcb_num = (bdos_fcb_num + 1) & 0x03;	// 0...3
		fcb_result = (struct FCB *)((word)bios_dma + bdos_fcb_num * 32);
		
		// Receive into this area
		r = host_receivefcb(fcb_result);
		
		// Result 0xff means error
		if (r == 0xff) return 0xff;
	
		// Return result fcb number (32-byte offset in DMA area, 0-3)
		return bdos_fcb_num;
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_sfirst");
		(void)fcb;	// Quiet the compiler
		return 0xff;
	#endif
}
*/
/*
byte bdos_f_snext_(struct FCB *fcb) {
	byte r;
	struct FCB *fcb_result;
	
	#ifdef BDOS_USE_HOST
		// Send given FCB
		host_sendfcb(BDOS_FUNC_F_SNEXT, fcb);
		
		// Chose free FCB in DMA area
		bdos_fcb_num = (bdos_fcb_num + 1) & 0x03;	// 0...3
		fcb_result = (struct FCB *)((word)bios_dma + bdos_fcb_num * 32);
		
		// Receive into this area
		r = host_receivefcb(fcb_result);
		
		// Result 0xff means error
		if (r == 0xff) return 0xff;
	
		// Return result fcb number (32-byte offset in DMA area, 0-3)
		return bdos_fcb_num;
		
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_snext");
		(void)fcb;	// Quiet the compiler
		return 0xff;
	#endif
}
*/

byte bdos_f_sfirst(struct FCB *fcb) __naked {	// BDOS_FUNC_F_SFIRST:	// 17: Search for first
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.
	// Search for the first occurrence of the specified file; the filename should be stored in the supplied FCB.
	// The filename can include ? marks
	//s = bdos_f_sfirst((struct FCB *)bdos_param_de);
	////bdos_return1(s);
	//bdos_return2(s, 0);
	__asm
		; Call actual C implementation
		;push de	; Push argument DE = FCB address
		;call _bdos_f_sfirst_
		;pop de	; Pop argument DE back
		
		; Call "universal" bdos_f_s_ implementation, supply function number as second parameter (first on stack)
		push bc	; Push argument BC: B=ignore, C=function
		push de	; Push argument DE = FCB address
		call _bdos_f_s_
		pop de	; Pop argument DE back
		pop bc	; Pop argument BC back
	
		; Result is in L
		
		; Return B=H=0
		ld a, #0
		ld b, a
		ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK=result 32-byte offset in DMA area)
		ld a, l
		ret
	__endasm;
}

byte bdos_f_snext(struct FCB *fcb) __naked {	// BDOS_FUNC_F_SNEXT:	// 18: Search for next
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=(address of FCB)? Returns error codes in BA and HL.
	//s = bdos_f_snext((struct FCB *)bdos_param_de);
	//bdos_return1(s);
	__asm
		; Call actual C implementation
		;push de	; Push argument DE = FCB address
		;call _bdos_f_snext_
		;pop de	; Pop argument DE back
		
		; Call "universal" bdos_f_s_ implementation, supply function number as second parameter (first on stack)
		push bc	; Push argument BC: B=ignore, C=function
		push de	; Push argument DE = FCB address
		call _bdos_f_s_
		pop de	; Pop argument DE back
		pop bc	; Pop argument BC back
		
		; Result is in L
		
		; Return B=H=0
		ld a, #0
		ld b, a
		ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK=result 32-byte offset in DMA area)
		ld a, l
		ret
	__endasm;
}

byte bdos_f_delete(struct FCB *fcb) __naked {	// BDOS_FUNC_F_DELETE:	// 19: Delete file
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.
	// Returns A=0FFh if error, otherwise 0-3
	
	//@TODO: Implement!
	bdos_not_implemented("f_delete");
	return 0xff;
}


byte bdos_f_read_(struct FCB *fcb) {
	
	#ifdef BDOS_USE_HOST
		byte r;
		
		word l;
		word rn;
		word ex;
		
		bdos_host_sendfcb(BDOS_FUNC_F_READ, fcb);
		
		// Receive immediate return value (OK, Hardware Error, EOF)
		r = bdos_host_receive_byte();
		if (r != 0x00) return r;
		
		// Receive data
		l = bdos_host_receivedma();
		
		// Return 1 on EOF
		//if (l == 0) return 1;	// 1 = EOF
		
		if (l < 128) {
			// Pad with EOF
			bdos_memset(bios_dma + l, 0x1a, 128 - l);
		}
		
		// Update current record in FCB
		/*
		bdos_file_ofs += l;
		fcb->cr = SEQ_CR(bdos_file_ofs);
		fcb->ex = SEQ_EX(bdos_file_ofs);
		fcb->s2 = (0x80 | SEQ_S2(bdos_file_ofs));
		*/
		
		rn = (word)fcb->cr + ((word)fcb->ex << 7) + ((word)(fcb->s2 & 1) << 14);
		rn++;
		ex = rn >> 7;	//	/ 128;
		fcb->cr = rn & 0x7f;	// % 128;
		fcb->ex = ex & 0x1f;	// % 32;
		fcb->s2 = (0x80 | (ex >> 5));
		
		//bdos_puts("readOK");
		return 0x00;
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_read");
		(void)fcb;
		//return 1;	// 1 = EOF
		return 0xff;	// 0xFF = Hardware error
	#endif
}
byte bdos_f_read(struct FCB *fcb) __naked {	// BDOS_FUNC_F_READ:	// 20: Read sequential
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.; H = number of 128-byte records read before error
	//	0	OK,
	//	1	end of file,
	//	9	invalid FCB,
	//	10	(CP/M) media changed; (MP/M) FCB checksum error,
	//	11	(MP/M) unlocked file verification error,
	//	0FFh	hardware error.
	//s = bdos_f_read((struct FCB *)bdos_param_de);
	//bdos_return2(s, 0);
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_read_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}

byte bdos_f_write_(struct FCB *fcb) {
	#ifdef BDOS_USE_HOST
		bdos_host_sendfcb(BDOS_FUNC_F_WRITE, fcb);
		//return 0xff;
		return 0x00;	// Fake "OK"
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_write");
		(void)fcb;	// Quiet the compiler
		return 0xff;
	#endif
	
}
byte bdos_f_write(struct FCB *fcb) __naked {	// BDOS_FUNC_F_WRITE:	// 21: Write sequential
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.
	//	0	OK,
	//	1	directory full,
	//	2	disc full,
	//	8	(MP/M) record locked by another process,
	//	9	invalid FCB,
	//	10	(CP/M) media changed; (MP/M) FCB checksum error,
	//	11	(MP/M) unlocked file verification error,
	//	0FFh	hardware error.
	//bdos_return1(bdos_f_write((struct FCB *)bdos_param_de));
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_write_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return B=H=0
		;ld a, #0
		;ld b, a
		;ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}

byte bdos_f_make(struct FCB *fcb) __naked {	// BDOS_FUNC_F_MAKE:	// 22: Make file
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.
	
	//@TODO: Implement!
	bdos_not_implemented("f_make");
	__asm
		ld l, #0xff	; 0xff if directory is full
		ret
	__endasm;
}

byte bdos_f_rename(struct FCB *fcb) __naked {	// BDOS_FUNC_F_RENAME:	// 23: Rename file
	(void)fcb;	// Silence the  compiler about unused argument
	// DE=address of FCB. Returns error codes in BA and HL.
	// Returns A=0-3 if successful; A=0FFh if error. Under CP/M 3, if H is zero then the file could not be found
	
	//@TODO: Implement!
	bdos_not_implemented("f_rename");
	return 0xff;
}

byte bdos_drv_loginvec() __naked {	// BDOS_FUNC_DRV_LOGINVEC:	// 24: Return login vector
	// Bit 7 of H corresponds to P: while bit 0 of L corresponds to A:. A bit is set if the corresponding drive is logged in.
	//bdos_return2(0x00, 0x01);	// 0x00 0x01 = Only drive A
	
	//@TODO: Create 16-bit map: L0=A: ... H7=P:
	__asm
		ld a, #0x00
		ld b, a
		ld h, a
		
		ld a, #0x0f
		ld l, a
		ret
	__endasm;
}

void bdos_drv_get() __naked {	// BDOS_FUNC_DRV_GET:	// 25: Return current disk
	// Entered with C=19h. Returns drive in A. Returns currently selected drive. 0 => A:, 1 => B: etc.
	//bdos_return1(bios_curdsk);
	__asm
		ld a, (_bios_curdsk)
		ret
	__endasm;
}

void bdos_f_dmaoff(char *de) __naked {	// BDOS_FUNC_F_DMAOFF:	// 26: Set DMA address
	(void)de;	// Silence the  compiler about unused argument
	// Entered with C=1Ah, DE=address.
	// Set the Direct Memory Access address; a pointer to where CP/M should read or write data.
	// Initially used for the transfer of 128-byte records between memory and disc, but over the years has gained many more functions.
	//bios_setdma((byte *)bdos_param_de);
	__asm
		push de
		call _bios_setdma
		pop de
		ret
	__endasm;
}

void bdos_drv_allocvec() __naked {	// BDOS_FUNC_DRV_ALLOCVEC:	// 27: Get addr (alloc)
	// BDOS function 27 (DRV_ALLOCVEC) - Return address of allocation map
	// Supported by: All versions, but differs in banked versions.
	// Entered with C=1Bh. Returns address in HL (16-bit versions use ES:BX).
	// Return the address of the allocation bitmap (which blocks are used and which are free) in HL. Under banked CP/M 3 and MP/M, this will be an address in bank 0 (the system bank) and not easily accessible.
	// Under previous versions, the format of the bitmap is a sequence of bytes, with bit 7 of the byte representing the lowest-numbered block on disc, and counting starting at block 0 (the directory). A bit is set if the corresponding block is in use.
	// Under CP/M 3, the allocation vector may be of this form (single-bit) or allocate two bits to each block (double-bit). This information is stored in the SCB.
	
	//@TODO: Implement!
	bdos_not_implemented("drv_allocvec");
	__asm
		ld h, #0x00
		ld l, #0x00
		ret
	__endasm;
}

// 28: Write protect disk
// 29: Get R/O vector
// 30: Set file attributes
// 31: Get addr (disk parms)

byte bdos_f_usernum() __naked {	// BDOS_FUNC_F_USERNUM:	// 32: Set/Get user code
	// BDOS function 32 (F_USERNUM) - get/set user number
	// Supported by: CP/M 2 and later.
	// Entered with C=20h, E=number. If E=0FFh, returns number in A.
	// Set current user number. E should be 0-15, or 255 to retrieve the current user number into A.
	// Some versions can use user areas 16-31, but these should be avoided for compatibility reasons.
	// DOS+ returns the number set in A.
	
	//@FIXME: User is usually stored in the upper bits of bios_curdsk [0x0004]
	__asm
		; e == 0xff?
		ld a, e
		cp a, #0xff
		jr z, 0$
		; Set user (and return it)
		ld (_bdos_user), a
		
	0$:
		; Return user
		ld a, (_bdos_user)
		ld l, a
		ret
	__endasm;
}

byte bdos_f_readrand_(struct FCB *fcb) {
	
	//bdos_printf("readrand"); bdos_printf_x2(fcb->r2); bdos_printf_x2(fcb->r1); bdos_printf_x2(fcb->r0); bdos_getchar();
	
	/*
	// Calculate absolute offset (in bytes)
	bdos_file_ofs = ((long)fcb->r0 + ((long)fcb->r1 * 256)) * 128L;
	fcb->cr = SEQ_CR(bdos_file_ofs);
	fcb->ex = SEQ_EX(bdos_file_ofs);
	fcb->s2 = (0x80 | SEQ_S2(bdos_file_ofs));
	*/
	
	/*
	// Calculate absolute offset (in records)
	rn = (word)fcb->r0 + ((word)fcb->r1 * 256);	// + r2 * 65536
	ex = rn >> 7;	// / 128;
	fcb->cr = rn & 0x7f;	// % 128;
	fcb->ex = ex & 0x1f;	// % 32;
	fcb->s2 = (0x80 | (ex >> 5));	// / 32));
	*/
	
	// Calculate new current record and ex from given r0-r2
	fcb->cr = fcb->r0 & 0x7f;	// bits 0...6 of r0
	fcb->ex = ((fcb->r0 & 0x80) >> 7) | ((fcb->r1 & 0x0f) << 1);	// bit 7 of r0 + bits 0...3 of r1
	fcb->s2 = ((fcb->r1 >> 4) & 0x0f);	// bits 4...7 of r1
	
	// Proceed with regular sequential read
	//return bdos_f_read_(fcb);
	
	#ifdef BDOS_USE_HOST
		byte r;
		
		word l;
		//word rn;
		//word ex;
		
		bdos_host_sendfcb(BDOS_FUNC_F_READ, fcb);
		
		// Receive immediate return value (OK, Hardware Error, EOF)
		r = bdos_host_receive_byte();
		if (r != 0x00) return r;
		
		// Receive data
		l = bdos_host_receivedma();
		
		// Return 1 on EOF
		//if (l == 0) return 1;	// 1 = EOF
		
		if (l < 128) {
			// Pad with EOF
			bdos_memset(bios_dma + l, 0x1a, 128 - l);
		}
		
		// Do not increment FCB current record on readrand
		
		//bdos_puts("readOK");
		return 0x00;
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_readrand");
		(void)fcb;
		return 0xff;	// 0xFF = Hardware error
	#endif
	
	
}
byte bdos_f_readrand(struct FCB *fcb) __naked {	// BDOS_FUNC_F_READRAND:	// 33: Read random
	(void)fcb;
	
	//s = bdos_f_readrand((struct FCB *)bdos_param_de);
	//bdos_return2(s, 0);
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_readrand_
		pop de	; Pop argument DE back
	
		; Result is in L
		
		; Return B=H=0
		ld a, #0
		ld b, a
		ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}


byte bdos_f_writerand_(struct FCB *fcb) {
	#ifdef BDOS_USE_HOST
		bdos_host_sendfcb(BDOS_FUNC_F_WRITERAND, fcb);
		//return 0xff;
		return 0x00;	// Fake "OK"
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_writerand");
		(void)fcb;	// Quiet the compiler
		return 0xff;
	#endif
}
byte bdos_f_writerand(struct FCB *fcb) __naked {	// BDOS_FUNC_F_WRITERAND:	// 34: Write random
	(void)fcb;
	
	//s = bdos_f_writerand((struct FCB *)bdos_param_de);
	//bdos_return2(s, 0);
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_writerand_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return B=H=0
		;ld a, #0
		;ld b, a
		;ld h, a
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}

void bdos_f_size(struct FCB *fcb) __naked {	// BDOS_FUNC_F_SIZE:	// 35: Compute file size
	(void)fcb;	// Silence the  compiler about unused argument
	
	bdos_not_implemented("f_size");
	//@TODO: Return "0", but update FCB's R0, R1, R2 records:
	// s.st_size >>= 7;
	// FCB_R0(fcb) = s.st_size & 0xff;
	// s.st_size >>= 8;
	// FCB_R1(fcb) = s.st_size & 0xff;
	// s.st_size >>= 8;
	// FCB_R2(fcb) = s.st_size & 1;
	return;
}

void bdos_f_randrec(struct FCB *fcb) __naked {	// BDOS_FUNC_F_RANDREC:	// 36: Set random record
	(void)fcb;	// Silence the  compiler about unused argument
	// Update FB.R0/R1/R2 to reflect current pos
	
	//@TODO: Im plement!
	bdos_not_implemented("f_randrec");
	
	// fcb->r0 = (bdos_file_ofs >> 7) & 0xff;
	// fcb->r1 = (bdos_file_ofs >> 7) >> 8;
	// fcb->r2 = (bdos_file_ofs >> 7) >> 16;
	// fcb->cr = SEQ_CR(bdos_file_ofs);
	// fcb->ex = SEQ_EX(bdos_file_ofs);
	// fcb->s2 = SEQ_S2(bdos_file_ofs);
	return;
}

void bdos_drv_reset() __naked {	// BDOS_FUNC_DRV_RESET:	// 37: Reset drive
	//bdos_puts("DRV_RST");
	bdos_not_implemented("drv_reset");
}

// 38: Undefined - go back

// 39: Undefined - go back

byte bdos_f_writezf_(struct FCB *fcb) {
	#ifdef BDOS_USE_HOST
		bdos_host_sendfcb(BDOS_FUNC_F_WRITEZF, fcb);
		
		//return 0xff;
		return 0x00;	// Fake "OK"
	#else
		//@TODO: Implement bare-metal version
		bdos_not_implemented("f_writezf");
		(void)fcb;	// Quiet the compiler
		return 0xff;
	#endif
}

byte bdos_f_writezf(struct FCB *fcb) __naked {	// BDOS_FUNC_F_WRITEZF:	// 40: Fill random file w/ zeros
	(void)fcb;	// Silence the  compiler about unused argument
	//bdos_return1(bdos_f_writezf((FCB *)bdos_param_de));
	__asm
		push de	; Push argument DE = FCB address
		call _bdos_f_writezf_
		pop de	; Pop argument DE back
		; Result is in L
		
		; Return A=L=status (0xff=error, 0-3=OK)
		ld a, l
		ret
	__endasm;
}


// Catch-all for unimplemented functions
void bdos_unimplemented() __naked {
	//@TODO: Also show function number (register C)
	bdos_puts("UNIMPL!");
	__asm
		; Return A=L=0xff
		ld a, #0xff
		ld l, #0xff
		ret
	__endasm;
}


// CCP startup
void bdos_start_ccp() {
	
	#ifdef BDOS_LOAD_CCP_FROM_DISK
	// Load CCP from a file! (Using BDOS functions fopen, fread, fclose...)
	byte r;
	byte *a;
	const char *filename;
	
	// Load data into CCP_LOC_CODE
	//addr = (byte *)0x0100;	// cpm_transient
	//addr = (byte *)CCP_LOC_CODE;
	a = (byte *)BDOS_CCP_LOAD_ADDRESS;
	
	filename = "CCP     COM\0";
	//filename = "ZORK1   COM\0";
	
	// Show loading CCP...
	//bdos_printf("Load CCP @ "); bdos_printf_x4((word)a); bdos_printf("...");
	
	bdos_fcb.dr = 0;	// Drive to load from
	bdos_memcpy(&bdos_fcb.f[0], &filename[0], 8+3);
	bdos_fcb.cr = 0;
	bdos_fcb.ex = 0;
	bdos_fcb.s1 = 0;
	bdos_fcb.s2 = 0;
	
	// Open file
	r = bdos_f_open_(&bdos_fcb);
	/*
	if (r != 0x00) {
		bdos_puts("Error!");
		bdos_getchar();
	}
	*/
	
	while (r == 0) {
		//bdos_putchar('.');	// Progress
		
		// Read next record
		r = bdos_f_read_(&bdos_fcb);
		// 0 = OK, 1 = EOF, 9 = invalid FCB, 10 = media changed/checksum error, 11 = unlocked/verification error, 0xff = hardware error
		if (r != 0) break;
		
		// Copy from DMA area to destination
		bdos_memcpy(a, (byte *)0x0080, 128);
		a += 128;
		
	}	// while(r == 0x00);
	
	//bdos_puts("OK");	//@TODO: 0=OK, 1=EOF, else=ERROR
	r = bdos_f_close_(&bdos_fcb);
	#endif
	
	// Clear DMA area at 0x0080 (contains CCP command line arguments)
	// You could also provide some start-up arguments (will be run by CCP as input, start with a space character)
	bdos_memset((byte *)0x0080, 0, 128);
	//*((byte *)0x0080) = 0;	// Clear CCP argl (dma area)
	//*((byte *)0x0081) = 0;	// Clear CCP args (dma area+1)
	
	// Verify what has been loaded
	//bdos_dump(BDOS_CCP_LOAD_ADDRESS, 32);
	
	// Invoke CCP entry point (must match LOC_CODE of ccp.c compilation!)
	//bdos_printf("Run CCP @ "); bdos_printf_x4((word)BDOS_CCP_JUMP_ADDRESS); bdos_printf("...");
	
	__asm
		jp BDOS_CCP_JUMP_ADDRESS
		;call BDOS_CCP_JUMP_ADDRESS
	__endasm;
	//bdos_puts("END");
}



// BDOS function jump table
void bdos_funcs() __naked {
	__asm
		jp _bdos_init	; BDOS_FUNC_P_TERMCPM:	// 0: System reset
		jp _bdos_c_read	; BDOS_FUNC_C_READ:	// 1: Console input
		jp _bdos_c_write	; BDOS_FUNC_C_WRITE:	// 2: Console output
		jp _bdos_a_read	; BDOS_FUNC_A_READ:	// 3: Reader input
		jp _bdos_a_write	; BDOS_FUNC_A_WRITE:	// 4: Punch output
		jp _bdos_l_write	; BDOS_FUNC_L_WRITE:	// 5: List output
		jp _bdos_c_rawio	; BDOS_FUNC_C_RAWIO:	// 6: Direct console I/O
		jp _bdos_get_iobyte	; BDOS_FUNC_GET_IOBYTE:	// 7: Get I/O Byte
		jp _bdos_set_iobyte	; BDOS_FUNC_SET_IOBYTE:	// 8: Set I/O Byte
		jp _bdos_c_writestr	; BDOS_FUNC_C_WRITESTR:	// 9: Print string (until delimiter "$")
		jp _bdos_c_readstr	; BDOS_FUNC_C_READSTR:	// 10: Read console buffer
		jp _bdos_c_stat	; BDOS_FUNC_C_STAT:	// 11: Get console status
		jp _bdos_s_bdosver	; BDOS_FUNC_S_BDOSVER:	// 12: Return version number
		
		jp _bdos_drv_allreset	; BDOS_FUNC_DRV_ALLRESET:	// 13: Reset disk system
		jp _bdos_drv_set	; BDOS_FUNC_DRV_SET:	// 14: Select disk
	
		jp _bdos_f_open	; BDOS_FUNC_F_OPEN:	// 15: Open file
		jp _bdos_f_close	; BDOS_FUNC_F_CLOSE:	// 16: Close file
		jp _bdos_f_sfirst	; BDOS_FUNC_F_SFIRST:	// 17: Search for first
		jp _bdos_f_snext	; BDOS_FUNC_F_SNEXT:	// 18: Search for next
		jp _bdos_f_delete	; BDOS_FUNC_F_DELETE:	// 19: Delete file
		jp _bdos_f_read	; BDOS_FUNC_F_READ:	// 20: Read sequential
		jp _bdos_f_write	; BDOS_FUNC_F_WRITE:	// 21: Write sequential
		jp _bdos_f_make	; BDOS_FUNC_F_MAKE:	// 22: Make file
		jp _bdos_f_rename	; BDOS_FUNC_F_RENAME:	// 23: Rename file
		
		jp _bdos_drv_loginvec	; BDOS_FUNC_DRV_LOGINVEC:	// 24: Return login vector
		jp _bdos_drv_get	; BDOS_FUNC_DRV_GET:	// 25: Return current disk
		jp _bdos_f_dmaoff	; BDOS_FUNC_F_DMAOFF:	// 26: Set DMA address
		jp _bdos_drv_allocvec	; BDOS_FUNC_DRV_ALLOCVEC:	// 27: Get addr (alloc)
		jp _bdos_unimplemented	; // 28: Write protect disk
		jp _bdos_unimplemented	; // 29: Get R/O vector
		jp _bdos_unimplemented	; // 30: Set file attributes
		jp _bdos_unimplemented	; // 31: Get addr (disk parms)
		jp _bdos_f_usernum	; BDOS_FUNC_F_USERNUM:	// 32: Set/Get user code
		jp _bdos_f_readrand	; BDOS_FUNC_F_READRAND:	// 33: Read random
		jp _bdos_f_writerand	; BDOS_FUNC_F_WRITERAND:	// 34: Write random
		jp _bdos_f_size	; BDOS_FUNC_F_SIZE:	// 35: Compute file size
		jp _bdos_f_randrec	; BDOS_FUNC_F_RANDREC:	// 36: Set random record
		jp _bdos_drv_reset	; BDOS_FUNC_DRV_RESET:	// 37: Reset drive
		jp _bdos_unimplemented	; // 38: Undefined - go back
		jp _bdos_unimplemented	; // 39: Undefined - go back
		jp _bdos_f_writezf	; BDOS_FUNC_F_WRITEZF:	// 40: Fill random file w/ zeros
		
		; Pad with "unimplemented" vector(s)
		jp _bdos_unimplemented
	__endasm;
}
//#endif	// __BDOS_C