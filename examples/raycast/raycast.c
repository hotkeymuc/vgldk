/*
	
	A crappy ass raycaster
	- no trigonometry
	- no perspective correction
	
	2020-07-07 Bernhard "HotKey" Slawik
*/

//#define TEXT_MODE
//#define GFX_MODE

#if VGLDK_SERIES == 6000
	#define GFX_MODE
#else
	#define TEXT_MODE
#endif



#define lcd_MINIMAL	// Use minimal text mode (no scrolling)
#include <vgldk.h>
#include <stdiomin.h>

#define alert(s) { lcd_x = 0; lcd_y = 0; puts(s); getchar(); }
//#define alert(s) ;


// Auto-generated by sintable.py
#define SINTABLE_INDEX_TYPE unsigned char
#define SINTABLE_SIZE 256
#define SINTABLE_VALUE_TYPE signed char
#define SINTABLE_SCALE 127
const SINTABLE_VALUE_TYPE SINTABLE[SINTABLE_SIZE] = {
	   0,    3,    6,    9,   12,   16,   19,   22,   25,   28,   31,   34,   37,   40,   43,   46,   49,   51,   54,   57,   60,   63,   65,   68,   71,   73,   76,   78,   81,   83,   85,   88,
	  90,   92,   94,   96,   98,  100,  102,  104,  106,  107,  109,  111,  112,  113,  115,  116,  117,  118,  120,  121,  122,  122,  123,  124,  125,  125,  126,  126,  126,  127,  127,  127,
	 127,  127,  127,  127,  126,  126,  126,  125,  125,  124,  123,  122,  122,  121,  120,  118,  117,  116,  115,  113,  112,  111,  109,  107,  106,  104,  102,  100,   98,   96,   94,   92,
	  90,   88,   85,   83,   81,   78,   76,   73,   71,   68,   65,   63,   60,   57,   54,   51,   49,   46,   43,   40,   37,   34,   31,   28,   25,   22,   19,   16,   12,    9,    6,    3,
	   0,   -3,   -6,   -9,  -12,  -16,  -19,  -22,  -25,  -28,  -31,  -34,  -37,  -40,  -43,  -46,  -49,  -51,  -54,  -57,  -60,  -63,  -65,  -68,  -71,  -73,  -76,  -78,  -81,  -83,  -85,  -88,
	 -90,  -92,  -94,  -96,  -98, -100, -102, -104, -106, -107, -109, -111, -112, -113, -115, -116, -117, -118, -120, -121, -122, -122, -123, -124, -125, -125, -126, -126, -126, -127, -127, -127,
	-127, -127, -127, -127, -126, -126, -126, -125, -125, -124, -123, -122, -122, -121, -120, -118, -117, -116, -115, -113, -112, -111, -109, -107, -106, -104, -102, -100,  -98,  -96,  -94,  -92,
	 -90,  -88,  -85,  -83,  -81,  -78,  -76,  -73,  -71,  -68,  -65,  -63,  -60,  -57,  -54,  -51,  -49,  -46,  -43,  -40,  -37,  -34,  -31,  -28,  -25,  -22,  -19,  -16,  -12,   -9,   -6,   -3
};
SINTABLE_VALUE_TYPE _sin(SINTABLE_INDEX_TYPE a) {
	return SINTABLE[a];
}
SINTABLE_VALUE_TYPE _cos(SINTABLE_INDEX_TYPE a) {
	return SINTABLE[(a + (SINTABLE_SIZE/4)) % SINTABLE_SIZE];
}


#define FOV (SINTABLE_SIZE / 8)
#define OVERSAMPLE_POS 8	// Player coordinate is scaled by this
#define SPEED_MOVE (OVERSAMPLE_POS/2)
#define SPEED_TURN 6


// Map
#define LEVEL_W 16
#define LEVEL_H 16
#define LEVEL_BLOCK_FREE ' '
const char LEVEL[LEVEL_W][LEVEL_H] = {
	{'#','#','#','#','#','#','#','#','#','#','#','#',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ','%',' ',' ','?',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#','#','#','#','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','%',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ', 32, 32,' ',' ',' ',' ','?',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ','%',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ','#','#','#','#','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
};


#ifdef TEXT_MODE
	#define OVERSAMPLE_RAY 2	// When pathtracing use enhanced z resolution
	
	#define SCREEN_W LCD_COLS
	#define SCREEN_H LCD_ROWS
	/*
	void lcd_putchar_at(int x, int y, char c) {
		lcd_x = x;
		lcd_y = y;
		lcd_putchar(c);
	}
*/
	
	
	#define CHAR_CEIL ' '
	#define CHAR_WALL 'X'
	#define CHAR_FLOOR ':'
	//#define CHAR_FLOOR ' '
	
	
	#define MAX_DEPTH 8
	const char COL_PATTERNS[MAX_DEPTH][SCREEN_H] = {
		{
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
		},
		{
			'-',
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
		},
		
		{
			'_',
			CHAR_WALL,
			CHAR_WALL,
			'_',
		},
		{
			CHAR_CEIL,
			'-',
			CHAR_WALL,
			'-',
		},
		{
			CHAR_CEIL,
			'_',
			'_',
			CHAR_FLOOR,
		},
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'=',
			CHAR_FLOOR,
		},
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'-',
			CHAR_FLOOR,
		},
		/*
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'_',
			CHAR_FLOOR,
		},
		*/
		{
			CHAR_CEIL,
			CHAR_CEIL,
			CHAR_CEIL,
			CHAR_FLOOR,
		},
	};
	
	
	void drawCol(byte x, int z, char b) {
	byte y;
	char c;
	
	z /= OVERSAMPLE_RAY;
	if (z >= MAX_DEPTH) z = MAX_DEPTH-1;	// z clip
	
	(void)b;	// Current block character
	
	for(y = 0; y < SCREEN_H; y++) {
		c = COL_PATTERNS[z][y];
		if (c == CHAR_WALL) c = b;
		lcd_putchar_at(x, y, c);
	}
	
}
#endif

#ifdef GFX_MODE
	#define OVERSAMPLE_RAY 4	// When pathtracing use enhanced z resolution

	//#define SCREEN_W 240
	//#define SCREEN_W 30
	//#define SCREEN_H 100
	
	// We are drawing 8 bits at a time
	#define SCREEN_W (LCD_W/8)
	#define SCREEN_H LCD_H
	#define MAX_DEPTH 10
void drawVLine(int x, int y1, int h, byte c) {
	byte *p;
	int y;
	if (y1 < 0) y1 = 0;
	if (y1+h > SCREEN_H) h = SCREEN_H - y1;
	
	//c = 0xff = black
	for(y = y1; y < y1+h; y++) {
		//p = (byte *)lcd_addr + (y * lcd_w + x) / 8;
		p = (byte *)lcd_addr + (y * lcd_w/8 + x);
		*p = c;
	}
}

void drawCol(int x, int z, char b) {
	byte c;
	byte h;
	byte y;
	byte yStart;
	
	byte *p;
	byte fbstep;
	
	if (z > OVERSAMPLE_RAY*MAX_DEPTH-1) z = OVERSAMPLE_RAY*MAX_DEPTH-1;	// z clip
	
	switch(b) {
		case LEVEL_BLOCK_FREE:	c = 0x00; break;
		case '?':	c = 1+8+64; break;
		case '%':	c = 0x55; break;
		case '#':	c = 0xff; break;
		default:
			c = 1+16;
	}
	
	//drawVLine(x, SCREEN_H/2 - z*2, z*4, c);
	//drawVLine(x, z * (SCREEN_H / (MAX_DEPTH*2)), SCREEN_H - z * (SCREEN_H / MAX_DEPTH), c);
	//h = (MAX_DEPTH * SCREEN_H * OVERSAMPLE_RAY*OVERSAMPLE_RAY) / (z*z + 1);
	h = (MAX_DEPTH * SCREEN_H * OVERSAMPLE_RAY*OVERSAMPLE_RAY) / (z*z + 2);
	if (h > SCREEN_H) h = SCREEN_H;
	//else if (h < 0) h = 0;
	
	yStart = SCREEN_H/2 - h/2;
	
	fbstep = lcd_w/8;
	// Ceiling
	y = 0;
	p = (byte *)(lcd_addr + x);	//(lcd_addr + (y * lcd_w/8 + x));
	while(y < yStart) {
		//*(byte *)(lcd_addr + (y * lcd_w/8 + x)) = 0x00;	//((y%2==0) ? 0x00 : 0xaa);
		*p = 0x00;
		//*p = (y%2==0) ? (1+16) : (4+64);
		p += fbstep;
		y++;
	}
	
	drawVLine(x, yStart, h, c);
	
	y = yStart + h;
	p = (byte *)(lcd_addr + (y * lcd_w/8 + x));
	// Floor
	while(y < SCREEN_H) {
		//*(byte *)(lcd_addr + (y * lcd_w/8 + x)) = ((y%2==0) ? 0x55 : 0xaa);
		*p = ((y%2==0) ? 0x55 : 0xaa);	// 50% gray
		//*p = ((y%2==0) ? 0x55 : 0xaa);	// 25% gray
		*p = (y%2==0) ? (1+16) : (4+64);	// 25% gray
		p += fbstep;
		y++;
	}
	
}
#endif

int player_x;
int player_z;
int player_a;


void drawScreen() {
	byte ix;
	byte iz;
	
	int a;
	SINTABLE_VALUE_TYPE dx;
	SINTABLE_VALUE_TYPE dz;
	
	int x;
	int z;
	char b;
	
	//lcd_clear();
	
	for(ix = 0; ix < SCREEN_W; ix++) {
		a = player_a + (FOV/2) - ((ix * FOV) / (SCREEN_W-1));
		if (a < 0) a += SINTABLE_SIZE;
		
		dx = _sin(a);
		dz = _cos(a);
		
		b = '?';
		for(iz = 0; iz < MAX_DEPTH*OVERSAMPLE_RAY; iz++) {
			//x = (player_x + (dx * iz * OVERSAMPLE) / (SINTABLE_SCALE*OVERSAMPLE_RAY)) / OVERSAMPLE;
			//z = (player_z + (dz * iz * OVERSAMPLE) / (SINTABLE_SCALE*OVERSAMPLE_RAY)) / OVERSAMPLE;
			
			x = player_x + (OVERSAMPLE_POS * dx * iz) / (SINTABLE_SCALE*OVERSAMPLE_RAY);
			x /= OVERSAMPLE_POS;
			
			z = player_z + (OVERSAMPLE_POS * dz * iz) / (SINTABLE_SCALE*OVERSAMPLE_RAY);
			z /= OVERSAMPLE_POS;
			
			if ((x < 0) || (x >= LEVEL_W) || (z < 0) || (z >= LEVEL_H)) {
				b = LEVEL_BLOCK_FREE;	//'!';
				break;
			}
			
			b = LEVEL[z][x];
			if (b != LEVEL_BLOCK_FREE) {
				// Hit a block
				
				//@TODO: Now go back slower or calculate the real distance
				
				//drawCol(ix, iz, b);
				break;
			}
		}
		
		if (b == LEVEL_BLOCK_FREE)
			drawCol(ix, MAX_DEPTH*OVERSAMPLE_RAY, b);
		else
			drawCol(ix, iz, b);
		
	}
}



void main() {
	char c;
	int move_a;
	int move_z;
	//SINTABLE_VALUE_TYPE sx;
	//SINTABLE_VALUE_TYPE sz;
	int sx;
	int sz;
	
	// Setup text mode
	//lcd_scroll_cb = NULL;	// Disable auto-scroll
	lcd_x = 0; lcd_y = 0;
	
	player_x = (OVERSAMPLE_POS * LEVEL_W) / 2;	// Center of map
	player_z = (OVERSAMPLE_POS * LEVEL_H) / 2;	// Center of map
	player_a = SINTABLE_SIZE / 2;	// Look up
	
	while(1) {
		
		drawScreen();
		
		/*
		lcd_x = 0; lcd_y = 0;
		puts("a="); printf_d(player_a);
		puts(" x="); printf_d(player_x);
		puts(" z="); printf_d(player_z);
		*/
		
		// Check keyboard
		move_a = 0;
		move_z = 0;
		
		c = getchar();
		switch(c) {
			case 'a':
			case 'A':
			#ifdef KEY_CURSOR_LEFT
			case KEY_CURSOR_LEFT:
			#endif
			#ifdef KEY_LEFT
			case KEY_LEFT:
			#endif
				move_a = -1;
				break;
			case 'd':
			case 'D':
			#ifdef KEY_CURSOR_RIGHT
			case KEY_CURSOR_RIGHT:
			#endif
			#ifdef KEY_RIGHT
			case KEY_RIGHT:
			#endif
				move_a = 1;
				break;
			
			case 'w':
			case 'W':
			#ifdef KEY_UP
			case KEY_UP:
			#endif
				move_z = 1;
				break;
			case 's':
			case 'S':
			#ifdef KEY_DOWN
			case KEY_DOWN:
			#endif
				move_z = -1;
				break;
		}
		
		
		// Handle movement
		if ((move_a != 0) || (move_z != 0)) {
			//player_a = (player_a + SINTABLE_SIZE - (move_a * SPEED_TURN)) % SINTABLE_SIZE;
			
			player_a -= (move_a * SPEED_TURN);
			if (player_a < 0) player_a += SINTABLE_SIZE;
			else player_a = player_a % SINTABLE_SIZE;
			
			sx = _sin(player_a);
			sz = _cos(player_a);
			//sz = _sin(player_a + SINTABLE_SIZE/4);
			
			
			// Move
			player_x += (move_z * SPEED_MOVE * sx) / SINTABLE_SCALE;
			player_z += (move_z * SPEED_MOVE * sz) / SINTABLE_SCALE;
			
			// Clip to map boundaries
			if (player_x < 0) {
				alert("X < 0!");
				player_x = 0;
			} else
			if (player_x >= (LEVEL_W*OVERSAMPLE_POS)) {
				alert("X > max!");
				player_x = (LEVEL_W-1)*OVERSAMPLE_POS;
			}
			
			if (player_z < 0) {
				alert("Z < 0!");
				player_z = 0;
			} else
			if (player_z >= (LEVEL_H*OVERSAMPLE_POS)) {
				alert("Z > max!");
				player_z = (LEVEL_H-1)*OVERSAMPLE_POS;
			}
			
			
			
			// Into wall? Move back!
			//while
			if (LEVEL[player_z/OVERSAMPLE_POS][player_x/OVERSAMPLE_POS] != LEVEL_BLOCK_FREE) {
				alert("Bump!");
				
				player_x -= (move_z * sx * SPEED_MOVE) / SINTABLE_SCALE;
				player_z -= (move_z * sz * SPEED_MOVE) / SINTABLE_SCALE;
			}
			
			
		}
		
	}
	
	
	//while(1) { }
}
