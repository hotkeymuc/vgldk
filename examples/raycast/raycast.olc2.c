/*
	Raycast
	=======
	
	A crappy ass raycaster
	
	Keys:
		* Cursor keys or WASD: Rotate/Move
		* N,M: Strafe
	
	2020-07-07 Bernhard "HotKey" Slawik
*/

//#define TEXT_MODE
//#define GFX_MODE

#if VGLDK_SERIES == 6000
	// GL6000SL defaults to GFX mod e(although it can also do text mode)
	#define GFX_MODE
#else
	// Default is text mode
	#define TEXT_MODE
#endif


#define lcd_MINIMAL	// Use minimal text mode (disable scrolling)
#include <vgldk.h>
#include <stdiomin.h>

// Helper to show some text
#define alert(s) { lcd_x = 0; lcd_y = 0; puts(s); getchar(); }
//#define alert(s) ;


// Auto-generated by sintable.py
#define SINTABLE_INDEX_TYPE unsigned char
#define SINTABLE_SIZE 256
#define SINTABLE_VALUE_TYPE signed char
#define SINTABLE_SCALE 127
const SINTABLE_VALUE_TYPE SINTABLE[SINTABLE_SIZE] = {
	   0,    3,    6,    9,   12,   16,   19,   22,   25,   28,   31,   34,   37,   40,   43,   46,   49,   51,   54,   57,   60,   63,   65,   68,   71,   73,   76,   78,   81,   83,   85,   88,
	  90,   92,   94,   96,   98,  100,  102,  104,  106,  107,  109,  111,  112,  113,  115,  116,  117,  118,  120,  121,  122,  122,  123,  124,  125,  125,  126,  126,  126,  127,  127,  127,
	 127,  127,  127,  127,  126,  126,  126,  125,  125,  124,  123,  122,  122,  121,  120,  118,  117,  116,  115,  113,  112,  111,  109,  107,  106,  104,  102,  100,   98,   96,   94,   92,
	  90,   88,   85,   83,   81,   78,   76,   73,   71,   68,   65,   63,   60,   57,   54,   51,   49,   46,   43,   40,   37,   34,   31,   28,   25,   22,   19,   16,   12,    9,    6,    3,
	   0,   -3,   -6,   -9,  -12,  -16,  -19,  -22,  -25,  -28,  -31,  -34,  -37,  -40,  -43,  -46,  -49,  -51,  -54,  -57,  -60,  -63,  -65,  -68,  -71,  -73,  -76,  -78,  -81,  -83,  -85,  -88,
	 -90,  -92,  -94,  -96,  -98, -100, -102, -104, -106, -107, -109, -111, -112, -113, -115, -116, -117, -118, -120, -121, -122, -122, -123, -124, -125, -125, -126, -126, -126, -127, -127, -127,
	-127, -127, -127, -127, -126, -126, -126, -125, -125, -124, -123, -122, -122, -121, -120, -118, -117, -116, -115, -113, -112, -111, -109, -107, -106, -104, -102, -100,  -98,  -96,  -94,  -92,
	 -90,  -88,  -85,  -83,  -81,  -78,  -76,  -73,  -71,  -68,  -65,  -63,  -60,  -57,  -54,  -51,  -49,  -46,  -43,  -40,  -37,  -34,  -31,  -28,  -25,  -22,  -19,  -16,  -12,   -9,   -6,   -3
};
SINTABLE_VALUE_TYPE _sin(SINTABLE_INDEX_TYPE a) {
	return SINTABLE[a];
}
SINTABLE_VALUE_TYPE _cos(SINTABLE_INDEX_TYPE a) {
	return SINTABLE[(a + (SINTABLE_SIZE/4)) % SINTABLE_SIZE];
}


// Settings
#define FOV (SINTABLE_SIZE / 6)	// Field of view
#define OVERSAMPLE_POS 8	// Player coordinate scale
#define SPEED_MOVE (OVERSAMPLE_POS/2)	// Speed for moving forward/back
#define SPEED_STRAFE (OVERSAMPLE_POS/2)	// Speed for moving sideways
#define SPEED_TURN 8	// Speed for turning
#define PERSPECTIVE_CORRECTION	// Remove fish-eye (hack)

// Player state
int player_x;
int player_z;
int player_a;


// Map
#define LEVEL_W 16
#define LEVEL_H 16
#define LEVEL_BLOCK_FREE ' '	// Which character means "can walk there"?
const char LEVEL[LEVEL_W][LEVEL_H] = {
	{'#','#','#','#','#','#','#','#','#','#','#','#',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ','%',' ',' ','?',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#','#','#','#','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','%',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ', 32, 32,' ',' ',' ',' ','?',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ','%',' ',' ',' ','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ','#','#','#','#','#'},
	{'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','%',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
	{'#',' ','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
};


#ifdef TEXT_MODE
	#define OVERSAMPLE_RAY 2	// When pathtracing use enhanced z resolution
	
	#define SCREEN_W LCD_COLS
	#define SCREEN_H LCD_ROWS
	/*
	void lcd_putchar_at(int x, int y, char c) {
		lcd_x = x;
		lcd_y = y;
		lcd_putchar(c);
	}
	*/
	
	#define CHAR_CEIL ' '
	#define CHAR_WALL 'X'
	#define CHAR_FLOOR ':'
	//#define CHAR_FLOOR ' '
	
	#define MAX_DEPTH 8
	// Column graphics
	const char COL_PATTERNS[MAX_DEPTH][SCREEN_H] = {
		{
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
		},
		{
			'-',
			CHAR_WALL,
			CHAR_WALL,
			CHAR_WALL,
		},
		
		{
			'_',
			CHAR_WALL,
			CHAR_WALL,
			'_',
		},
		{
			CHAR_CEIL,
			'-',
			CHAR_WALL,
			'-',
		},
		{
			CHAR_CEIL,
			'_',
			'_',
			CHAR_FLOOR,
		},
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'=',
			CHAR_FLOOR,
		},
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'-',
			CHAR_FLOOR,
		},
		/*
		{
			CHAR_CEIL,
			CHAR_CEIL,
			'_',
			CHAR_FLOOR,
		},
		*/
		{
			CHAR_CEIL,
			CHAR_CEIL,
			CHAR_CEIL,
			CHAR_FLOOR,
		},
	};
	
	
	void drawCol(byte x, int z, char b) {
		// Draw one column of graphics
		byte y;
		char c;
		
		z /= OVERSAMPLE_RAY;
		if (z >= MAX_DEPTH) z = MAX_DEPTH-1;	// z clip
		
		for(y = 0; y < SCREEN_H; y++) {
			c = COL_PATTERNS[z][y];
			if (c == CHAR_WALL) c = b;	// Replace wall character by block character
			lcd_putchar_at(x, y, c);
		}
	}
#endif

#ifdef GFX_MODE
	#define OVERSAMPLE_RAY 4	// Enhanced ray cast resolution - This hugely increases calculation time!
	
	//#define SCREEN_W 240
	//#define SCREEN_W 30
	//#define SCREEN_H 100
	
	// We are drawing 8 bits at a time
	#define SCREEN_W (LCD_W/8)
	#define SCREEN_H LCD_H
	#define MAX_DEPTH 16
	
	#define FB_INC (LCD_W/8)	// How far to increment on the frame buffer to be on next line
	void drawVLine(int x, int y1, int h, byte c) {
		byte *p;
		int y;
		if (y1 < 0) y1 = 0;
		if (y1+h > SCREEN_H) h = SCREEN_H - y1;
		
		//c = 0xff = black
		p = (byte *)lcd_addr + y1*FB_INC + x;
		for(y = y1; y < y1+h; y++) {
			//p = (byte *)lcd_addr + (y * lcd_w + x) / 8;
			//p = (byte *)lcd_addr + (y * lcd_w/8 + x);
			*p = c;
			p += FB_INC;
		}
	}
	
	void drawCol(int x, int z, char b) {
		// Draw one column of graphics
		
		byte c;
		unsigned int h;
		//word zz;
		byte y;
		byte yStart;
		
		byte *p;
		
		if (z > OVERSAMPLE_RAY*MAX_DEPTH-1) z = OVERSAMPLE_RAY*MAX_DEPTH-1;	// z clip
		
		switch(b) {
			case LEVEL_BLOCK_FREE:	c = 0x00; break;
			case '?':	c = 1+8+64; break;
			case '%':	c = 0x55; break;
			case '#':	c = 0xff; break;
			default:
				c = 1+16;
		}
		
		
		// Calculate the height of the wall column
		//h = (MAX_DEPTH * SCREEN_H * OVERSAMPLE_RAY) / (z*4 + 1);
		
		// This is the tricky part (making it look nice)
		//h = (SCREEN_H * OVERSAMPLE_RAY*OVERSAMPLE_RAY) / (1 + z*z);
		//h = (SCREEN_H * OVERSAMPLE_RAY) / (1 + 3*z);
		h = (SCREEN_H * OVERSAMPLE_RAY) / (1 + z);
		
		if (h > SCREEN_H) h = SCREEN_H;
		//else if (h < 0) h = 0;
		
		// Draw column
		yStart = SCREEN_H/2 - h/2;
		
		// Ceiling
		y = 0;
		p = (byte *)(lcd_addr + x);	//(y * lcd_w/8 + x));
		while(y < yStart) {
			*p = 0x00;	// white
			//*p = ((y%2==0) ? 0x55 : 0xaa);	// 50% gray
			//*p = (y%2==0) ? (1+16) : (4+64);	// 25% gray
			p += FB_INC;
			y++;
		}
		
		// Wall
		drawVLine(x, yStart, h, c);
		
		// Floor
		y = yStart + h;
		p = (byte *)(lcd_addr + (y * lcd_w/8 + x));
		while(y < SCREEN_H) {
			//*(byte *)(lcd_addr + (y * lcd_w/8 + x)) = ((y%2==0) ? 0x55 : 0xaa);
			//*p = ((y%2==0) ? 0x55 : 0xaa);	// 50% gray
			*p = (y%2==0) ? (1+16) : (4+64);	// 25% gray
			//*p = ((y%2==0) ? 0x55 : 0xaa);	// stripes
			p += FB_INC;
			y++;
		}
		
	}
#endif



void drawScreen() {
	byte ix;
	byte iz;
	
	int a;
	int ar;
	#ifdef PERSPECTIVE_CORRECTION
		int dx;
		int dz;
	#else
		SINTABLE_VALUE_TYPE dx;
		SINTABLE_VALUE_TYPE dz;
	#endif
	
	int x;
	int z;
	char b;
	
	//lcd_clear();
	
	for(ix = 0; ix < SCREEN_W; ix++) {
		ar = (FOV/2) - ((ix * FOV) / (SCREEN_W-1));	// Relative angle
		a = player_a + ar;
		if (a < 0) a += SINTABLE_SIZE;
		
		dx = _sin(a);
		dz = _cos(a);
		
		// Cast ray
		b = '?';
		for(iz = 0; iz < MAX_DEPTH*OVERSAMPLE_RAY; iz++) {
		//for(iz = 0; iz < MAX_DEPTH*OVERSAMPLE_RAY; iz += (1 + iz/16)) {	// Speed up in the distance
			
			// Ray position
			x = player_x + (OVERSAMPLE_POS * dx * iz) / (SINTABLE_SCALE*OVERSAMPLE_RAY);
			x /= OVERSAMPLE_POS;
			
			z = player_z + (OVERSAMPLE_POS * dz * iz) / (SINTABLE_SCALE*OVERSAMPLE_RAY);
			z /= OVERSAMPLE_POS;
			
			// Check bounds
			if ((x < 0) || (x >= LEVEL_W) || (z < 0) || (z >= LEVEL_H)) {
				b = LEVEL_BLOCK_FREE;	//'!';
				break;
			}
			
			// Check if we hit something
			b = LEVEL[z][x];
			if (b != LEVEL_BLOCK_FREE) {
				// Hit a block
				
				//@TODO: Refine: Now go back slower or calculate the real distance
				
				//drawCol(ix, iz, b);
				break;
			}
		}
		
		#ifdef PERSPECTIVE_CORRECTION
			// Fish eye correction hack
			// dis1 = abs(int(dis1 * costable[abs(x - colsh)]/ans))	# // OVER
			//iz = _cos((a + SINTABLE_SIZE - FOV/2) % SINTABLE_SIZE) * iz / dx;
			if (ar < 0) ar = -ar;	// abs()
			iz = (iz * (1 + (SINTABLE_SIZE/2 + ar)) / (SINTABLE_SIZE/3));
			if (iz < 0) iz = -iz;
		#endif
		
		//if (b == LEVEL_BLOCK_FREE)
		//	drawCol(ix, MAX_DEPTH*OVERSAMPLE_RAY, b);
		//else
		drawCol(ix, iz, b);
		
	}
}



void main() {
	char c;
	int move_a;	// Rotation
	int move_x;	// Strafe
	int move_z;	// Move forward
	//SINTABLE_VALUE_TYPE sx;
	//SINTABLE_VALUE_TYPE sz;
	int sx;
	int sz;
	
	// Setup text mode
	//lcd_scroll_cb = NULL;	// Disable auto-scroll
	lcd_x = 0; lcd_y = 0;
	
	player_x = (OVERSAMPLE_POS * LEVEL_W) / 2;	// Center of map
	player_z = (OVERSAMPLE_POS * LEVEL_H) / 2;	// Center of map
	player_a = SINTABLE_SIZE / 2;	// Look up
	
	while(1) {
		
		drawScreen();
		
		/*
		lcd_x = 0; lcd_y = 0;
		puts("a="); printf_d(player_a);
		puts(" x="); printf_d(player_x);
		puts(" z="); printf_d(player_z);
		*/
		
		// Check keyboard
		move_a = 0;
		move_x = 0;
		move_z = 0;
		
		c = getchar();
		switch(c) {
			case 'a':
			case 'A':
			#ifdef KEY_CURSOR_LEFT
			case KEY_CURSOR_LEFT:
			#endif
			#ifdef KEY_LEFT
			case KEY_LEFT:
			#endif
				move_a = 1;
				break;
			case 'd':
			case 'D':
			#ifdef KEY_CURSOR_RIGHT
			case KEY_CURSOR_RIGHT:
			#endif
			#ifdef KEY_RIGHT
			case KEY_RIGHT:
			#endif
				move_a = -1;
				break;
			
			case 'w':
			case 'W':
			#ifdef KEY_UP
			case KEY_UP:
			#endif
				move_z = 1;
				break;
			case 's':
			case 'S':
			#ifdef KEY_DOWN
			case KEY_DOWN:
			#endif
				move_z = -1;
				break;
			
			case 'n':
			case 'N':
				move_x = -1;
				break;
			case 'm':
			case 'M':
				move_x = 1;
				break;

		}
		
		
		// Handle movement
		if ((move_a != 0) || (move_x != 0) || (move_z != 0)) {
			//player_a = (player_a + SINTABLE_SIZE - (move_a * SPEED_TURN)) % SINTABLE_SIZE;
			
			player_a += (move_a * SPEED_TURN);
			if (player_a < 0) player_a += SINTABLE_SIZE;
			else player_a = player_a % SINTABLE_SIZE;
			
			// Movement forward/back
			sx  = move_z * _sin(player_a) * SPEED_MOVE;
			sz  = move_z * _cos(player_a) * SPEED_MOVE;
			
			// Movement sideways
			sx -= move_x * _sin(player_a + SINTABLE_SIZE/4) * SPEED_STRAFE;
			sz -= move_x * _cos(player_a + SINTABLE_SIZE/4) * SPEED_STRAFE;
			//sz = _sin(player_a + SINTABLE_SIZE/4);
			
			// Move player position
			player_x += sx / SINTABLE_SCALE;
			player_z += sz / SINTABLE_SCALE;
			
			// Clip to map boundaries
			if (player_x < 0) {
				alert("X < 0!");
				player_x = 0;
			} else
			if (player_x >= (LEVEL_W*OVERSAMPLE_POS)) {
				alert("X > max!");
				player_x = (LEVEL_W-1)*OVERSAMPLE_POS;
			}
			
			if (player_z < 0) {
				alert("Z < 0!");
				player_z = 0;
			} else
			if (player_z >= (LEVEL_H*OVERSAMPLE_POS)) {
				alert("Z > max!");
				player_z = (LEVEL_H-1)*OVERSAMPLE_POS;
			}
			
			// Into wall? Move back!
			//while
			if (LEVEL[player_z/OVERSAMPLE_POS][player_x/OVERSAMPLE_POS] != LEVEL_BLOCK_FREE) {
				alert("Bump!");
				
				player_x -= sx / SINTABLE_SCALE;
				player_z -= sz / SINTABLE_SCALE;
			}
			
			
		}
		
	}
	
	
	//while(1) { }
}
